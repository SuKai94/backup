[《深入理解Java虚拟机》](http://book.douban.com/subject/6522893/)
===

## 第二章 Java内存区域与内存溢出异常

### 2.2 运行时数据区域

![Java运行时数据区域](https://raw.githubusercontent.com/su-kaiyao/record/master/others/imgs/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png)

- 程序计数器：一块较小的内存空间，可以看作是当前线程所执行的字节码的行号显示器。字节码解释器工作通过改变计数器的值选取下一个需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖计数器完成。为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，即线程私有

- Java虚拟机栈：也是线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法执行同时创建一个栈桢用于存储局部变量表，操作栈，动态连接，方法出口等信息，每一个方法被调用至执行完成的过程，就对应着一个栈桢在虚拟机栈中从入栈到出栈的过程。如果线程请求的栈深度大于虚拟机所允许的的深度，将抛出StackOverFlow;如果虚拟机栈可以动态扩展，当扩展到无法申请到足够内存时候，抛出OutOfMemoryError。

- 本地方法栈：与虚拟机栈作用相似，区别在于：虚拟机栈为虚拟机执行Java方法，本地栈为虚拟机使用到的Native方法服务。抛出的异常也是两个。

- Java堆：这是Java虚拟机管理的最大一块，它是被所有线程共享的一块内存区域，由虚拟机启动时创建。其存在的唯一目的就是存放对象实例（所有对象实例以及数组都要在堆上分配内存）。Java堆也是垃圾回收管理的主要区域，有时候也被称作GC堆。

- 方法区：与Java堆相似，也是各个线程共享的区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError。

- 运行时常量池：运行时常量池是方法区的一部分。Class文件除了有类的版本，字段，方法，接口等信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放在方法区的运行时常量池。运行时常量池受方法去内存限制，也会抛出OutOfMemoryError。

- 直接内存：直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。在JDK1.4之后的NIO中，通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作，避免在Java堆和Native堆之间来回复制数据。显然，本机直接内存的分配不受到Java堆大小限制，但是受到本机总内存的大小以及处理器寻址空间的限制，动态扩展时也会抛出OutOfMemoryError。

### 2.3 对象访问

对象访问在Java中无处不在，即使是最简单的访问，也会涉及Java栈，Java堆，方法区这三个最重要的内存区域。`Object obj = new Object()`，其中`Object obj`会反映到Java栈的本地变量表，作为一个reference出现，而`new Object()`反映到Java堆中，形成一块存储了Object类型所有实例数据值的结构化内存。
由于reference类型在Java虚拟机规范里面只规定一个指向对象的引用，并没有规定这个引用通过哪种方式去定位，以及访问到Java堆中对象的具体位置，因此不同虚拟机实现方式不同：
- 句柄访问方式：Java堆中将划出一块内存作为句柄池，reference存储的就是对象的句柄地址，句柄中包含了对象实例数据和类型数据各自的具体地址信息

![句柄访问方式](https://raw.githubusercontent.com/su-kaiyao/record/master/others/imgs/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F.png)

- 直接指针访问方式：reference直接存储的就是对象地址

![指针访问方式](https://raw.githubusercontent.com/su-kaiyao/record/master/others/imgs/%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F.png)

使用句柄访问方式好处是reference中存储的是最稳定的句柄地址，在对象被移动（垃圾回收经常要移动）时，只会改变句柄中的实例数据指针，reference无需修改。
直接指针访问方式好处是访问速度快

### 2.4 实战：OutOfMemoryError

#### 2.4.1 Java堆溢出

Java堆用于存储对象实例，我们只要不断创建对象，并保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量到达最大堆容量的时候发生溢出。Java堆OOM异常是最常见的，异常堆栈信息"java.lang.OutOfMemoryError"会跟着"Java heap space"

#### 2.4.2 虚拟机栈和本地方法栈溢出

- 如果线程请求的栈深度大于虚拟机允许的最大深度，将抛出StackOverFlow。
- 如果虚拟机在扩展时无法申请到足够的内存空间，则抛出OutOfMemoryError。
可以使用-Xss参数减少栈内存容量;也可以定义大量的本地变量，增加此方法帧中本地变量表的长度。

#### 2.4.3 运行时常量池溢出

向运行时常量池添加内容，最简单的做法是使用`string.intern()`

#### 2.4.4 方法区溢出

方法区用于存放Class的相关信息，如类名，访问修饰符，常量池，字段描述，方法描述等。测试思路是运行产生大量的类去填充方法区，直到溢出。

#### 2.4.5 本机直接内存溢出

DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定就与Java堆的最大值（-Xmx指定）一样。

### 2.5 本章小结

本章学习，我们明白了虚拟机内存是如何分配的，那部分区域，什么样的代码和操作可能导致内存溢出。下一章将讲述Java垃圾回收机制为了避免内存溢出异常的出现做了哪些努力。


## 第三章 垃圾收集器与内存分配策略

Java与C++之间有一堵由内存分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。

### 3.1 概述

程序计数器，虚拟机栈，本地方法栈三个区域随着线程而生，随线程而灭。栈中的栈帧随着方法的进入和退出而有条不絮地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具有确定性。也无需多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。而Java堆和方法区不一样，我们只有在程序运行期才能知道会创建哪些对象，这部分内存分配和回收是动态的，垃圾收集器所关注的是这部分的内存。

### 3.2 对象已死？

垃圾收集器在对堆进行回收之前，需要确定对象是活是死！

#### 3.2.1 引用计数算法

很多教科书判断对象是否存活的算法是这样的：给对象添加一个引用计数器，每当一个地方引用它，计数器加1;当引用失效，计数器就减1。任何时刻计数器为0的对象就是不可能再被使用。

#### 3.2.2 根搜索算法

算法基本思路是：通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连，则证明此对象是不可用的。

在Java语言中，可以作为GC Roots的对象有：

- 虚拟机栈（栈帧中本地变量表）中引用的对象
- 方法区中的类静态属性引用的对象
- 方法区中的常量引用的对象
- 本地方法栈中JNI（即一般说的Native方法）的引用的对象

#### 3.2.3 再谈引用

在JDK 1.2之后，Java对引用的概念进行了扩充，分为强引用，软引用，弱引用，虚引用，强度依次减弱

- 强引用：在程序代码中普遍存在，`Object obj = new Object()`，只要强引用存在，垃圾收集器永远不会回收被引用的对象
- 软引用：用来描述一些还有用，但并非必需的对象。系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够内存，就抛出内存溢出异常。
- 弱引用：描述非必需对象。被引用对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会收掉只被弱引用关联的对象。
- 虚引用：一个对象是否存在虚引用，完全不会对其生存时间产生影响，也无法通过虚引用来获得一个对象实例。当一个对象设置为虚引用关联，唯一目的就是希望能在这个对象被收集器回收之前收到系统通知。

#### 3.2.4 生存还是死亡？

在根搜索算法中不可达对象，并不是“非死不可”的，这时处于“缓刑”阶段。如果对象在进行根搜索后发现没有和GC Roots相关联的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已被虚拟机执行过，虚拟机就认为“没有必要执行”。如果对象被判定为有必要执行finalize()方法，那么就会被放置在F-Queue队列之中，稍后有虚拟机自动创建的，低优先级的Finalizer线程执行。所以对象如果想在finalize()方法中拯救自己，就重新与引用链上任何一个对象建立关联即可。但是finalize()方法只能被系统自动调用一次，如果对象面临下一次的回收，它的finalize()方法就不会再次执行。

### 3.3 垃圾收集算法

方法区进行垃圾回收的性价比一般比较低：在堆中，尤其是新生代中，常规引用进行垃圾回收一般可以收集70%~95%，而永久代垃圾收集效率远低于此。

#### 3.3.1 标记－清楚算法

这是最基础的算法。算法分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，然后统一收集掉所有被标记的对象，标记过程如前面对象标记判定所述。主要缺点有：1.效率低。2.空间问题，标记清除后产生大量不连续内存碎片，导致程序需要分配大对象时无法找到足够连续内存而不得不提前触发另一次垃圾回收。

![标记-清除算法]()

#### 3.3.2 复制算法

将可用内存分为大小相等的两块，每次只使用其中一块。当一块内存用完了，就将还存活对象复制到另一块，然后再把已使用过的内存空间一次清理掉。这使得每次都是对其中一块内存回收，内存分配时不用考虑空间碎片，只要移动堆顶指针，按顺序分配内存即可，代价就是内存缩小为原来的一般。

![复制算法]()

#### 3.3.3 标记－整理算法

标记过程和“标记－清除算法”一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。

![标记-整理算法]()

#### 3.3.4 分代收集算法

当前商业垃圾收集器都采用此算法，只是根据对象存活周期分为几块。一般是把Java堆分为新生代和老年代。在新生代采用复制算法，因为大多数对象即将死去。而老年代则采用“标记－清除”或“标记－整理”算法。

### 3.4 垃圾收集器

如果说收集算法是内存回收的方法论，那么收集器就是内存回收的具体实现。
