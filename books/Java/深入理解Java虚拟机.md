《深入理解Java虚拟机》
===

## 第二章 Java内存区域与内存溢出异常

### 2.2 运行时数据区域

![Java运行时数据区域](https://raw.githubusercontent.com/su-kaiyao/record/master/others/imgs/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png)

- 程序计数器：一块较小的内存空间，可以看作是当前线程所执行的字节码的行号显示器。字节码解释器工作通过改变计数器的值选取下一个需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖计数器完成。为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，即线程私有

- Java虚拟机栈：也是线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法执行同时创建一个栈桢用于存储局部变量表，操作栈，动态连接，方法出口等信息，每一个方法被调用至执行完成的过程，就对应着一个栈桢在虚拟机栈中从入栈到出栈的过程。如果线程请求的栈深度大于虚拟机所允许的的深度，将抛出StackOverFlow;如果虚拟机栈可以动态扩展，当扩展到无法申请到足够内存时候，抛出OutOfMemoryError。

- 本地方法栈：与虚拟机栈作用相似，区别在于：虚拟机栈为虚拟机执行Java方法，本地栈为虚拟机使用到的Native方法服务。抛出的异常也是两个。

- Java堆：这是Java虚拟机管理的最大一块，它是被所有线程共享的一块内存区域，由虚拟机启动时创建。其存在的唯一目的就是存放对象实例（所有对象实例以及数组都要在堆上分配内存）。Java堆也是垃圾回收管理的主要区域，有时候也被称作GC堆。

- 方法区：与Java堆相似，也是各个线程共享的区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError。

- 运行时常量池：运行时常量池是方法区的一部分。Class文件除了有类的版本，字段，方法，接口等信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放在方法区的运行时常量池。运行时常量池受方法去内存限制，也会抛出OutOfMemoryError。

- 直接内存：直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。在JDK1.4之后的NIO中，通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作，避免在Java堆和Native堆之间来回复制数据。显然，本机直接内存的分配不受到Java堆大小限制，但是受到本机总内存的大小以及处理器寻址空间的限制，动态扩展时也会抛出OutOfMemoryError。

### 2.3 对象访问

对象访问在Java中无处不在，即使是最简单的访问，也会涉及Java栈，Java堆，方法区这三个最重要的内存区域。`Object obj = new Object()`，其中`Object obj`会反映到Java栈的本地变量表，作为一个reference出现，而`new Object()`反映到Java堆中，形成一块存储了Object类型所有实例数据值的结构化内存。
由于reference类型在Java虚拟机规范里面只规定一个指向对象的引用，并没有规定这个引用通过哪种方式去定位，以及访问到Java堆中对象的具体位置，因此不同虚拟机实现方式不同：
- 句柄访问方式：Java堆中将划出一块内存作为句柄池，reference存储的就是对象的句柄地址，句柄中包含了对象实例数据和类型数据各自的具体地址信息

![句柄访问方式](https://raw.githubusercontent.com/su-kaiyao/record/master/others/imgs/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F.png)

- 直接指针访问方式：reference直接存储的就是对象地址

![指针访问方式](https://raw.githubusercontent.com/su-kaiyao/record/master/others/imgs/%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F.png)

使用句柄访问方式好处是reference中存储的是最稳定的句柄地址，在对象被移动（垃圾回收经常要移动）时，只会改变句柄中的实例数据指针，reference无需修改。
直接指针访问方式好处是访问速度快

### 2.4 实战：OutOfMemoryError

#### 2.4.1 Java堆溢出

Java堆用于存储对象实例，我们只要不断创建对象，并保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量到达最大堆容量的时候发生溢出。Java堆OOM异常是最常见的，异常堆栈信息"java.lang.OutOfMemoryError"会跟着"Java heap space"

#### 2.4.2 虚拟机栈和本地方法栈溢出

- 如果线程请求的栈深度大于虚拟机允许的最大深度，将抛出StackOverFlow。
- 如果虚拟机在扩展时无法申请到足够的内存空间，则抛出OutOfMemoryError。
可以使用-Xss参数减少栈内存容量;也可以定义大量的本地变量，增加此方法帧中本地变量表的长度。

#### 2.4.3 运行时常量池溢出

向运行时常量池添加内容，最简单的做法是使用`string.intern()`

#### 2.4.4 方法区溢出

方法区用于存放Class的相关信息，如类名，访问修饰符，常量池，字段描述，方法描述等。测试思路是运行产生大量的类去填充方法区，直到溢出。

#### 2.4.5 本机直接内存溢出

DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定就与Java堆的最大值（-Xmx指定）一样。

### 2.5 本章小结

本章学习，我们明白了虚拟机内存是如何分配的，那部分区域，什么样的代码和操作可能导致内存溢出。下一章将讲述Java垃圾回收机制为了避免内存溢出异常的出现做了哪些努力。



